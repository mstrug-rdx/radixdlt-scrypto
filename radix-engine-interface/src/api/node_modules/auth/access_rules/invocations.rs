use crate::api::ObjectModuleId;
use crate::blueprints::resource::*;
use crate::*;
#[cfg(feature = "radix_engine_fuzzing")]
use arbitrary::Arbitrary;
use radix_engine_common::data::scrypto::model::Own;
use sbor::rust::fmt::Debug;
use sbor::rust::prelude::*;

pub const ACCESS_RULES_BLUEPRINT: &str = "AccessRules";

pub const ACCESS_RULES_CREATE_IDENT: &str = "create";

#[cfg_attr(feature = "radix_engine_fuzzing", derive(Arbitrary))]
#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct AccessRulesCreateInput {
    pub owner_role: OwnerRole,
    pub roles: BTreeMap<ObjectModuleId, RolesInit>,
}

pub type AccessRulesCreateOutput = Own;

pub const ACCESS_RULES_SET_ROLE_IDENT: &str = "set_role";

#[cfg_attr(feature = "radix_engine_fuzzing", derive(Arbitrary))]
#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct AccessRulesSetRoleInput {
    pub module: ObjectModuleId,
    pub role_key: RoleKey,
    pub rule: AccessRule,
}

pub type AccessRulesSetRoleOutput = ();

pub const ACCESS_RULES_LOCK_ROLE_IDENT: &str = "lock_role";

#[cfg_attr(feature = "radix_engine_fuzzing", derive(Arbitrary))]
#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct AccessRulesLockRoleInput {
    pub module: ObjectModuleId,
    pub role_key: RoleKey,
}

pub type AccessRulesLockRoleOutput = ();

pub const ACCESS_RULES_SET_AND_LOCK_ROLE_IDENT: &str = "set_and_lock_role";

#[cfg_attr(feature = "radix_engine_fuzzing", derive(Arbitrary))]
#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct AccessRulesSetAndLockRoleInput {
    pub module: ObjectModuleId,
    pub role_key: RoleKey,
    pub rule: AccessRule,
}

pub type AccessRulesSetAndLockRoleOutput = ();

pub const ACCESS_RULES_SET_OWNER_ROLE_IDENT: &str = "set_owner_role";

#[cfg_attr(feature = "radix_engine_fuzzing", derive(Arbitrary))]
#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct AccessRulesSetOwnerRoleInput {
    pub rule: AccessRule,
}

pub type AccessRulesSetOwnerRoleOutput = ();

pub const ACCESS_RULES_LOCK_OWNER_ROLE_IDENT: &str = "lock_owner_role";

#[cfg_attr(feature = "radix_engine_fuzzing", derive(Arbitrary))]
#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct AccessRulesLockOwnerRoleInput {}

pub type AccessRulesLockOwnerRoleOutput = ();

pub const ACCESS_RULES_SET_AND_LOCK_OWNER_ROLE_IDENT: &str = "set_and_lock_owner_role";

#[cfg_attr(feature = "radix_engine_fuzzing", derive(Arbitrary))]
#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct AccessRulesSetAndLockOwnerRoleInput {
    pub rule: AccessRule,
}

pub type AccessRulesSetAndLockOwnerRoleOutput = ();

pub const ACCESS_RULES_GET_ROLE_IDENT: &str = "get_role";

#[cfg_attr(feature = "radix_engine_fuzzing", derive(Arbitrary))]
#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct AccessRulesGetRoleInput {
    pub module: ObjectModuleId,
    pub role_key: RoleKey,
}

pub type AccessRulesGetRoleOutput = Option<AccessRule>;

pub trait ToRoleEntry {
    fn to_role_entry(self) -> Option<AccessRule>;
}

impl ToRoleEntry for AccessRule {
    fn to_role_entry(self) -> Option<AccessRule> {
        Some(self)
    }
}

#[derive(Debug, Clone, Eq, PartialEq, ScryptoSbor)]
pub enum FallToOwner {
    OWNER,
}

impl ToRoleEntry for FallToOwner {
    fn to_role_entry(self) -> Option<AccessRule> {
        match self {
            FallToOwner::OWNER => None,
        }
    }
}

#[macro_export]
macro_rules! internal_roles {
    ($module_roles:ident, $($role:ident => $rule:expr, $locked:ident;)* ) => ({
        let method_roles = $module_roles::<(Option<AccessRule>, bool)> {
            $(
                $role: {
                    role_definition_entry!($rule, $locked)
                }
            ),*
        };

        let mut roles = $crate::blueprints::resource::RolesInit::new();
        for (name, (rule, locked)) in method_roles.list() {
            roles.define_role_raw(name, rule, locked);
        }

        roles
    });
}

#[macro_export]
macro_rules! role_definition_entry {
    ($rule:expr, locked) => {{
        ($rule.to_role_entry(), true)
    }};
    ($rule:expr, updatable) => {{
        ($rule.to_role_entry(), false)
    }};
}
